<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Research Proposal</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Research Proposal</h1>
</header>
<h2 id="problem-statement">Problem Statement</h2>
<blockquote>
<p>Given a Boundary Value Problem (BVP) and a mesh over its
computational domain, <br> optimise the coordinates of the mesh to
obtain a high accuracy Finite Element Methods (FEM) solution, <br> while
utilising the underlying physics of the problem.</p>
</blockquote>
<h2 id="origin-of-the-problem">Origin of the problem</h2>
<p>In Science and Engineering, quantities which are continuous functions
of space and time are modelled as a BVP. In a BVP, we are given a
domain, Partial Differential Equations (PDEs) to be solved and the
constraints to be imposed at the boundary of the domain. As an example,
simulation of the airflow around an airfoil is modelled by a BVP.
Airfoils are objects of shapes which can, for favourable airflow,
generate lift (countering the gravitational forces) like the wings of a
turbine or aircraft. For airflow simulation, the Navier-Stokes Equations
(NSE) describe the physics at each point in the domain in the form of
PDEs. To specify the inflow, outflow and the friction of the air with
the airfoil we impose boundary conditions on the velocity and pressure
at the surface of the airfoil and a rectangle around the airfoil marking
the region of interest as described in figure . The first step for
numerically solving such PDEs, is to generate a mesh over the region of
interest. The FEM with nodal basis functions for a good quality mesh and
appropriate element sizes provide accurate and reliable solutions, but
computational power can be a limiting factor in obtaining solutions of
the desired accuracy. Our research is focused on balancing the
computational cost and accuracy to find an optimal mesh while exploiting
the parallel computing possibilities.</p>
<p>Time-independent BVPs capture the steady state of the system, while
time-dependent ones capture the evolution. A steady state occurs when
the system no longer changes significantly with time and the transience
has died down. The Reynolds number, a dimensionless quantity
representing the ratio of inertial to viscous forces, is a measure of
turbulence in the system. Higher Reynolds numbers often necessitate
finer grids and smaller time steps to resolve turbulent features like
eddies and vortices while maintaining numerical stability.</p>
<h2 id="proposed-methodologies">Proposed Methodologies</h2>
<p>The goal is to begin with a coarse mesh and optimise the mesh
coordinates to obtain solutions of enhanced accuracy. First, we will
develop the algorithm for the 2 dimensional Poisson’s problem with <a
href="notes/mms.pdf">manufactured solutions</a> as it will be good way
to understand if our methods improves accuracy.</p>
<p>The basic plan to be implemented for time-independent BVP is given
below.</p>
<ol type="1">
<li><p>To generate the initial coarse mesh, the Triangle package in
Python will be used.</p></li>
<li><p>After the assembly of the stiffness matrix and the consistent
load vector the FEM solution will be computed using the linear solver in
the Numpy or Scipy package in Python.</p></li>
<li><p>A loss function will be defined based on a-posteriori error
estimates, like the element residual method, which will take as inputs
the mesh coordinates and the FEM solution on the mesh.</p></li>
<li><p>An iteration of a gradient based method, using the TensorFlow
package, will applied to tweak the mesh coordinates to reduce the loss
value.</p></li>
<li><p>Another method which utilises the TensorFlow package will be used
corect the FEM solution for the tweaked mesh. This will be possible as
only the coordinates of the nodes have changed and not the connections
between them.</p></li>
<li><p>We have to loop through steps 4 and 5 to achieve a desirable mesh
and a solution on it.</p></li>
</ol>
<p>Starting from the Poisson’s problem, we will move to singularly
perturbed problems, convection-diffusion problem, lid driven cavity
problem, channel flow problem, flow past circular cylinder problem, and
then finally the airfoil problem. The airfoil specifications will be
chosen from the National Advisory Committee for Aeronautics (NACA) <a
href="http://airfoiltools.com/search/index?m%5Bgrp%5D=naca4d&amp;m%5Bsort%5D=1">database.</a></p>
<h2 id="on-optimising-mesh-coordinates">On optimising mesh
coordinates</h2>
<p>Find the descripation and result of <a href="mesh_optim1.pdf">one of
the simple ways</a> of forming a mesh by formulating a rule based on
which the node positions will be decided. Here, the total potential is
calculated using the pairwise Morse potential between all pairs of
nodes. In my implementation, using TensorFlow, for finding the pairwise
distances I have used the concept of sparse matirces in the following
way.</p>
<pre><code>import tensorflow as tf

N = 65                      # Number of points

row_id = 0
indices = []
values = []
for i in range(N-1):
    for j in range(i+1,N):
        # print(i,j)
        indices.append([row_id,i])
        indices.append([row_id,j])
        values.append(1.0)
        values.append(-1.0)
        row_id += 1

diff_tf = tf.sparse.SparseTensor(indices, values, [row_id,N])</code></pre>
<p>This sparse matrix is used to evaluate the total potential, defined
as loss in the following code.</p>
<pre><code>def loss(x,y):
    diffx = tf.sparse.sparse_dense_matmul(diff_tf, x)
    diffy = tf.sparse.sparse_dense_matmul(diff_tf, y)
    # Using the Morse potential
    d = tf.sqrt(diffx**2 + diffy**2) - re
    return tf.reduce_sum(tf.square(1 - tf.exp(-a*d)))</code></pre>
<p>Note that here any type of boundary is not considered.</p>
<p>Another <a href="mesh_optim2.pdf">toy problem</a> shows how mesh
coordinates can be optimised using a gradient descent stratergy. As an
example, the objective function considered is the variation in the area
of the elements. Here the boundary nodes are not moved as the gradients
are not applied on them.</p>
<hr />
<p>Links to <a href="../index.html">homepage</a>, <a
href="../resume/Resume.pdf">resume</a>, <a
href="../proj.html">projects</a>, and <a
href="../more.html">more…</a></p>
</body>
</html>
